"""
general functions for collecting clamlab event ping files generated by bonsai
"""


# basic definitions:
# sub-session: individual bonsai session for a subject
# session: all sub-sessions for a subject, in a given day


from collections import defaultdict
import pandas as pd
from pyfun.customdict import AddOnlyDict
import os, glob
import pyfun.timestrings as timestr


def get_subfolders(searchpath, level=1):
    '''
    get subfolders
    :param searchpath:
    :param level: how deep to search
    :return:
    '''

    if level==1:
        subfolders = [[f.name, f.path] for f in os.scandir(searchpath) if f.is_dir()]
    else:
        raise ValueError('Sorry only have level 1 now.')

    return subfolders


def process_subfolders(subfolders):
    """
    Generator function, which iterates through a list of subfolders
    ([fd.name, fd.path]) and checks if fd.name contains datestring.
    Yields each [fd.name, fd.path] for which the datestring exists.
    """

    for [fd_name, fd_path] in subfolders:

        fd_dateinfo = timestr.search(fd_name, verbose=False)  # search for a timestamp in folder name
        if fd_dateinfo is not None:
            yield [fd_name, fd_path]


def get_subsess_paths(animal_name, animal_root, remove_prefix='results_', verbose=False):
    """
    scrape data folder for one animal, and return all the corresponding data files, grouped by timestamp
    It is assumed that the file structure is:

    animal_id/datetime/results_datetime2/DataFileName.csv

    where DataFileName can be e.g. "Events", "body_xy" etc. These names are automatically extracted
    from the file name itself


    #in bonsai there is a new session folder (datetime) created when bonsai is first launched
    #each session has a results subfolder (results_datetime2), and stopping and re-starting
    #bonsai creates multiple results subfolder within that same session folder.

    :param animal_root: path to data folder containing all sessions belonging to one animal
    :return:
    """

    #some results somefolders have earlier timestamps than the parent session folder
    #this is an error resulting from results folders created in the main code directory
    #e.g. during debugging but not deleted

    timestamp_errors = [] #store these timestamp mismatches


    subsess_paths = defaultdict(AddOnlyDict)

    subfolders_1 = get_subfolders(animal_root)  # one level down

    for [subfolder_1_name, subfolder_1_path] in process_subfolders(subfolders_1):
        subfolder_1_date = timestr.search(subfolder_1_name)[1]

        subfolders_2 = get_subfolders(subfolder_1_path)  # two levels down

        for [subfolder_2_name, subfolder_2_path] in process_subfolders(subfolders_2):

            subfolder_2_date = timestr.search(subfolder_2_name)[1]

            # ===check that timestamp of inner subfolder is later than timestamp of outer subfolder
            if subfolder_1_date > subfolder_2_date:
                # reformat full path for simplicity
                path = os.path.normpath(subfolder_1_path)
                parts = path.split(os.sep)[-2:]

                timestamp_errors.append([os.path.join(parts[-2], parts[-1]), subfolder_2_name])
                continue


            file_searchstr = os.path.join(subfolder_2_path, '*.csv')
            filenames = [os.path.basename(f) for f in glob.glob(file_searchstr)]

            for fn in filenames:
                file_type = fn.split('.')[0]
                subsess_paths[subfolder_2_name.replace(remove_prefix, '')][file_type] = os.path.join(subfolder_2_path, fn)

    return subsess_paths, timestamp_errors


def get_subsess_paths_old(animal_name, animal_root, verbose=False):
    """
    NOTE: DEPRECATED 03.21.23
    scrape data folder for one animal, and return all the corresponding data files, grouped by timestamp
    It is assumed that the file structure is:

    animal_id/datetime/results/*.csv

    :param animal_folder: path to data folder containing all sessions belonging to one animal
    :return:
    """


    subsess_paths = defaultdict(AddOnlyDict)

    subfolders = [[f.name, f.path] for f in os.scandir(animal_root) if f.is_dir()]

    for [fd_name, fd_path] in subfolders:

        fd_dateinfo = timestr.search(fd_name)  # search for a timestamp in folder name
        if fd_dateinfo is None:
            if verbose:
                print(fd_name, fd_path)
            continue  # folder is not a sub-session folder

        # ==grab all csv files in results for of each sub-session
        fd_path = os.path.join(fd_path, 'results')
        file_searchstr = os.path.join(fd_path, '*.csv')
        filenames = [os.path.basename(f) for f in glob.glob(file_searchstr)]

        for fn in filenames:
            file_dateinfo = timestr.search(fn)  # find time string in filename

            if file_dateinfo is None:  # no timestring found, ignore file
                if verbose:
                    print(fn)
                continue

            # ===check that timestamp of file is later than timestamp of folder
            if fd_dateinfo[1] > file_dateinfo[1]:
                print(os.path.join(fd_path, fn))
                raise ValueError(
                    "Error! File {} \noccurs earlier than folder {} ".format(file_dateinfo[0], fd_dateinfo[0]))

            file_type, file_animal_name = fn.split('_')[0:2]

            # ===check that animal_name matches===
            if file_animal_name.upper() != animal_name:
                print(os.path.join(fd_path, fn))
                raise ValueError("Error! Filename {} found in folder {}".format(file_animal_name, animal_name))

            subsess_name = file_dateinfo[0]
            subsess_paths[subsess_name][file_type] = os.path.join(fd_path, fn)

    return subsess_paths
